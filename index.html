<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cross-Platform ANT+ Receiver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            min-height: 100vh;
            color: #333;
            padding: 10px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        @media (min-width: 768px) {
            .header h1 {
                font-size: 2.5rem;
            }
            .container {
                padding: 20px;
            }
            .header {
                margin-bottom: 30px;
            }
        }

        .platform-info {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            color: white;
            backdrop-filter: blur(10px);
        }

        .platform-detected {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        .permission-panel {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .permission-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 8px;
            background: #f8f9fa;
        }

        .permission-granted {
            background: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .permission-denied {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .permission-unknown {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
        }

        .connection-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .connection-options {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        @media (min-width: 768px) {
            .connection-options {
                grid-template-columns: 1fr 1fr;
            }
        }

        .connection-method {
            border: 2px solid #ecf0f1;
            border-radius: 10px;
            padding: 15px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .connection-method.available {
            border-color: #2ecc71;
            background: #e8f5e8;
        }

        .connection-method.unavailable {
            border-color: #e74c3c;
            background: #fdf2f2;
            opacity: 0.6;
            cursor: not-allowed;
        }

        .connection-method.active {
            border-color: #3498db;
            background: #e3f2fd;
            transform: scale(1.02);
        }

        .method-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .method-title {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .method-description {
            font-size: 0.9rem;
            color: #666;
        }

        .devices-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        @media (min-width: 768px) {
            .devices-grid {
                grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
                gap: 20px;
                margin-bottom: 30px;
            }
        }

        .device-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            opacity: 0.6;
        }

        .device-card.receiving {
            opacity: 1;
            transform: translateY(-2px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
            border: 2px solid #2ecc71;
        }

        .device-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .device-icon {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .trainer .device-icon { background: linear-gradient(45deg, #ff6b6b, #ff8e8e); }
        .hrm .device-icon { background: linear-gradient(45deg, #a8e6cf, #7fcdcd); }

        .device-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .device-status {
            font-size: 0.8rem;
            color: #7f8c8d;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-active { background-color: #2ecc71; }
        .status-inactive { background-color: #e74c3c; }
        .status-searching { background-color: #f39c12; animation: pulse 1s infinite; }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        @media (min-width: 768px) {
            .metrics {
                grid-template-columns: 1fr 1fr 1fr;
                gap: 10px;
            }
        }

        .metric {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .metric.updated {
            background: #d4edda;
            transform: scale(1.05);
        }

        .metric-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #2c3e50;
        }

        @media (min-width: 768px) {
            .metric-value {
                font-size: 1.6rem;
            }
        }

        .metric-label {
            font-size: 0.7rem;
            color: #7f8c8d;
            text-transform: uppercase;
        }

        .btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
            width: 100%;
            margin: 5px 0;
        }

        .btn:hover {
            background: linear-gradient(45deg, #2980b9, #1f639a);
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .btn-scan {
            background: linear-gradient(45deg, #27ae60, #229954);
        }

        .btn-stop {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .btn-permission {
            background: linear-gradient(45deg, #f39c12, #d68910);
        }

        .warning-message {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #856404;
        }

        .error-message {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #721c24;
        }

        .success-message {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #155724;
        }

        .log-section {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .log-content {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .hr-zone {
            text-align: center;
            margin: 10px 0;
            padding: 8px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .zone-1 { background: #e8f5e8; color: #27ae60; }
        .zone-2 { background: #fff3cd; color: #f39c12; }
        .zone-3 { background: #ffeaa7; color: #fdcb6e; }
        .zone-4 { background: #fab1a0; color: #e17055; }
        .zone-5 { background: #fd79a8; color: #e84393; }

        .android-instructions {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .android-instructions h4 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .android-instructions ul {
            margin-left: 20px;
        }

        .android-instructions li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üì° Cross-Platform ANT+ Receiver</h1>
            <p>Android, Windows, Mac & iOS Compatible</p>
        </div>

        <div class="platform-info">
            <div class="platform-detected" id="platform-detected">üîç Detecting platform...</div>
            <div id="platform-capabilities">Checking connection capabilities...</div>
        </div>

        <!-- Android-specific instructions -->
        <div id="android-instructions" class="android-instructions" style="display: none;">
            <h4>üì± Android Setup Instructions</h4>
            <p><strong>Important:</strong> This page must be served over HTTPS for Bluetooth to work on Android.</p>
            <ul>
                <li>Open Chrome browser (other browsers may not support Web Bluetooth)</li>
                <li>Enable "Experimental Web Platform features" in chrome://flags</li>
                <li>Grant location permission when prompted (required for Bluetooth scanning)</li>
                <li>Make sure Bluetooth is enabled in Android settings</li>
                <li>Keep your ANT+ devices in pairing mode</li>
            </ul>
        </div>

        <!-- Permission Status Panel -->
        <div class="permission-panel">
            <h3>üîê Permissions & Requirements</h3>
            
            <div class="permission-item" id="https-status">
                <div>
                    <strong>üîí HTTPS Connection</strong>
                    <div style="font-size: 0.8rem; color: #666;">Required for Web Bluetooth on mobile</div>
                </div>
                <span id="https-indicator">‚ùì</span>
            </div>

            <div class="permission-item" id="bluetooth-api-status">
                <div>
                    <strong>üì∂ Web Bluetooth API</strong>
                    <div style="font-size: 0.8rem; color: #666;">Browser support for Bluetooth devices</div>
                </div>
                <span id="bluetooth-api-indicator">‚ùì</span>
            </div>

            <div class="permission-item" id="location-status" style="display: none;">
                <div>
                    <strong>üìç Location Permission</strong>
                    <div style="font-size: 0.8rem; color: #666;">Required for Bluetooth scanning on Android</div>
                </div>
                <div>
                    <span id="location-indicator">‚ùì</span>
                    <button class="btn btn-permission" id="request-location-btn" onclick="requestLocationPermission()" style="display: none; margin-left: 10px; width: auto; padding: 5px 10px;">Grant</button>
                </div>
            </div>

            <div class="permission-item" id="bluetooth-status">
                <div>
                    <strong>üîµ Bluetooth Device Access</strong>
                    <div style="font-size: 0.8rem; color: #666;">Permission to connect to Bluetooth devices</div>
                </div>
                <span id="bluetooth-indicator">‚ùì</span>
            </div>
        </div>

        <div class="connection-panel">
            <h3>üîó Connection Methods</h3>
            
            <!-- Warning for USB on Android -->
            <div id="usb-android-warning" class="warning-message" style="display: none;">
                <strong>‚ö†Ô∏è USB ANT+ Not Available on Android</strong><br>
                Android devices cannot access USB ANT+ sticks through web browsers. Use Bluetooth ANT+ devices instead.
            </div>

            <div class="connection-options">
                <!-- USB ANT+ Method -->
                <div class="connection-method" id="usb-method">
                    <div class="method-icon">üîå</div>
                    <div class="method-title">USB ANT+ Stick</div>
                    <div class="method-description">Direct USB connection (Windows/Mac/Linux only)</div>
                    <button class="btn" id="usb-connect-btn" onclick="connectUSB()" disabled>Connect USB</button>
                </div>

                <!-- Bluetooth ANT+ Method -->
                <div class="connection-method" id="bluetooth-method">
                    <div class="method-icon">üì±</div>
                    <div class="method-title">Bluetooth ANT+</div>
                    <div class="method-description">Bluetooth Low Energy (All platforms)</div>
                    <button class="btn" id="bluetooth-connect-btn" onclick="connectBluetooth()" disabled>Scan Bluetooth</button>
                </div>
            </div>

            <!-- Specific device scanning buttons -->
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 15px;">
                <button class="btn btn-scan" id="scan-kickr-btn" onclick="pairKickr()" disabled>Pair Kickr Core</button>
                <button class="btn btn-scan" id="scan-zwift-btn" onclick="pairZwiftClick()" disabled>Pair Zwift Click</button>
                <button class="btn btn-scan" id="scan-hrm-btn" onclick="pairHRM()" disabled>Pair Heart Rate</button>
            </div>

            <div id="connection-status" style="margin-top: 15px; padding: 10px; border-radius: 5px; display: none;">
                <strong>Status:</strong> <span id="status-text">Disconnected</span>
            </div>
        </div>

        <div class="devices-grid">
            <!-- Wahoo Kickr Core Card -->
            <div class="device-card trainer" id="kickr-card">
                <div class="device-header">
                    <div class="device-icon" style="background: linear-gradient(45deg, #ff6b6b, #ff8e8e);">üö¥</div>
                    <div>
                        <div class="device-title">Wahoo Kickr Core</div>
                        <div class="device-status">
                            <span class="status-indicator" id="kickr-status"></span>
                            <span id="kickr-status-text">No Signal</span>
                        </div>
                        <div style="font-size: 0.7rem; color: #999;">
                            Device Type: FE-C (0x11) | Channel: 5 | Device ID: <span id="kickr-device-id">12345</span>
                        </div>
                        <div style="font-size: 0.7rem; color: #999;">
                            RF Frequency: <span id="kickr-frequency">2457 MHz</span>
                        </div>
                    </div>
                </div>

                <div class="metrics">
                    <div class="metric" id="kickr-power-metric">
                        <div class="metric-value" id="kickr-power-value">---</div>
                        <div class="metric-label">Power (W)</div>
                    </div>
                    <div class="metric" id="kickr-resistance-metric">
                        <div class="metric-value" id="kickr-resistance-value">---</div>
                        <div class="metric-label">Resistance (%)</div>
                    </div>
                    <div class="metric" id="kickr-cadence-metric">
                        <div class="metric-value" id="kickr-cadence-value">---</div>
                        <div class="metric-label">Cadence (RPM)</div>
                    </div>
                    <div class="metric" id="kickr-speed-metric">
                        <div class="metric-value" id="kickr-speed-value">---</div>
                        <div class="metric-label">Speed (KM/H)</div>
                    </div>
                    <div class="metric" id="kickr-distance-metric">
                        <div class="metric-value" id="kickr-distance-value">---</div>
                        <div class="metric-label">Distance (KM)</div>
                    </div>
                    <div class="metric" id="kickr-time-metric">
                        <div class="metric-value" id="kickr-time-value">---</div>
                        <div class="metric-label">Time</div>
                    </div>
                </div>

                <!-- Kickr Controls -->
                <div style="margin-top: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span style="font-weight: 600;">Target Power (W)</span>
                        <span id="kickr-target-power" style="font-weight: bold; color: #2c3e50;">150</span>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="font-weight: 600; margin-bottom: 5px; display: block;">Resistance (%)</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="background: #34495e; color: white; padding: 2px 8px; border-radius: 3px; font-size: 0.8rem;">-10%</span>
                            <input type="range" id="kickr-resistance-slider" min="-10" max="10" value="0" style="flex: 1;" onchange="updateKickrResistance(this.value)">
                            <span style="background: #34495e; color: white; padding: 2px 8px; border-radius: 3px; font-size: 0.8rem;">+10%</span>
                        </div>
                        <div style="text-align: center; margin-top: 5px; font-size: 1.2rem; font-weight: bold;" id="kickr-resistance-display">0</div>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <button class="btn" style="background: linear-gradient(45deg, #f39c12, #d68910);" onclick="pairKickr()">Pair Device</button>
                    <button class="btn btn-stop" onclick="stopKickr()">Stop Trainer</button>
                </div>

                <div id="kickr-last-update" style="text-align: center; font-size: 0.8rem; color: #666; margin-top: 10px;">
                    Waiting for data...
                </div>
            </div>

            <!-- Zwift Click Card -->
            <div class="device-card" id="zwift-click-card" style="background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%);">
                <div class="device-header">
                    <div class="device-icon" style="background: linear-gradient(45deg, #28a745, #20c997);">‚ö°</div>
                    <div>
                        <div class="device-title">Zwift Click</div>
                        <div class="device-status">
                            <span class="status-indicator" id="zwift-status"></span>
                            <span id="zwift-status-text">No Signal</span>
                        </div>
                        <div style="font-size: 0.7rem; color: #999;">
                            Device Type: Shifting (0x22) | Channel: 5 | Device ID: <span id="zwift-device-id">23456</span>
                        </div>
                        <div style="font-size: 0.7rem; color: #999;">
                            RF Frequency: <span id="zwift-frequency">2457 MHz</span>
                        </div>
                    </div>
                </div>

                <!-- Zwift Click Controls -->
                <div style="display: flex; justify-content: center; align-items: center; margin: 20px 0;">
                    <button class="btn" style="background: #6c757d; width: 60px; height: 60px; border-radius: 50%; font-size: 1.5rem; margin: 0 20px;" onclick="zwiftShiftDown()">-</button>
                    <div style="text-align: center;">
                        <div style="font-size: 3rem; font-weight: bold; color: #2c3e50;" id="zwift-gear">4</div>
                        <div style="font-size: 0.8rem; color: #666;">Current Gear</div>
                    </div>
                    <button class="btn" style="background: #6c757d; width: 60px; height: 60px; border-radius: 50%; font-size: 1.5rem; margin: 0 20px;" onclick="zwiftShiftUp()">+</button>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px;">
                    <div class="metric">
                        <div class="metric-value" id="zwift-front-gear">50</div>
                        <div class="metric-label">Front (?)</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="zwift-rear-gear">14</div>
                        <div class="metric-label">Rear (?)</div>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <button class="btn" style="background: linear-gradient(45deg, #f39c12, #d68910);" onclick="pairZwiftClick()">Pair Device</button>
                    <button class="btn btn-stop" onclick="stopZwiftClick()">Stop Shifter</button>
                </div>

                <div id="zwift-last-update" style="text-align: center; font-size: 0.8rem; color: #666; margin-top: 10px;">
                    Waiting for data...
                </div>
            </div>

            <!-- Heart Rate Monitor Card -->
            <div class="device-card hrm" id="hrm-card">
                <div class="device-header">
                    <div class="device-icon" style="background: linear-gradient(45deg, #a8e6cf, #7fcdcd);">‚ù§Ô∏è</div>
                    <div>
                        <div class="device-title">Heart Rate Monitor</div>
                        <div class="device-status">
                            <span class="status-indicator" id="hrm-status"></span>
                            <span id="hrm-status-text">No Signal</span>
                        </div>
                        <div style="font-size: 0.7rem; color: #999;">
                            Device Type: Heart Rate (0x78) | Channel: 5 | Device ID: <span id="hrm-device-id">34567</span>
                        </div>
                        <div style="font-size: 0.7rem; color: #999;">
                            RF Frequency: <span id="hrm-frequency">2457 MHz</span>
                        </div>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <div class="metric" id="hr-current-metric">
                        <div class="metric-value" id="hr-current-value">---</div>
                        <div class="metric-label">BPM</div>
                    </div>
                    <div class="metric" id="hr-avg-metric">
                        <div class="metric-value" id="hr-avg-value">---</div>
                        <div class="metric-label">Avg BPM</div>
                    </div>
                </div>

                <div class="hr-zone" id="hr-zone">Zone Unknown</div>

                <div style="margin: 15px 0;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span style="font-size: 0.8rem;">Base Heart Rate (BPM)</span>
                        <span style="font-size: 0.8rem;" id="base-hr">65</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span style="font-size: 0.8rem;">Max Heart Rate (BPM)</span>
                        <span style="font-size: 0.8rem;" id="max-hr">185</span>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <button class="btn" style="background: linear-gradient(45deg, #f39c12, #d68910);" onclick="pairHRM()">Pair Device</button>
                    <button class="btn btn-stop" onclick="stopHRM()">Stop HRM</button>
                </div>

                <div id="hrm-last-update" style="text-align: center; font-size: 0.8rem; color: #666; margin-top: 10px;">
                    Waiting for data...
                </div>
            </div>
        </div>

        <!-- Log Section -->
        <div class="log-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3>üìã Connection Log</h3>
                <button onclick="clearLog()" style="background: #95a5a6; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Clear</button>
            </div>
            <div class="log-content" id="log-content"></div>
        </div>
    </div>

    <script>
        let currentConnection = null;
        let platform = null;
        let connectedDevices = new Map();
        let sessionData = {
            trainer: { distance: 0, startTime: null, maxPower: 0 },
            hrm: { avgHR: 0, maxHR: 0, hrHistory: [] }
        };
        let permissionStatus = {
            https: false,
            webBluetooth: false,
            location: 'prompt',
            bluetooth: 'prompt'
        };

        // Platform detection with Android-specific handling
        function detectPlatform() {
            const userAgent = navigator.userAgent.toLowerCase();
            const isMobile = /android|iphone|ipad|ipod|blackberry|iemobile|opera mini/.test(userAgent);
            const isAndroid = /android/.test(userAgent);
            const isIOS = /iphone|ipad|ipod/.test(userAgent);
            const isWindows = /windows/.test(userAgent);
            const isMac = /macintosh|mac os x/.test(userAgent);
            const isLinux = /linux/.test(userAgent);

            let platformName = 'Unknown';
            if (isAndroid) platformName = 'Android';
            else if (isIOS) platformName = 'iOS';
            else if (isWindows) platformName = 'Windows';
            else if (isMac) platformName = 'macOS';
            else if (isLinux) platformName = 'Linux';

            platform = {
                name: platformName,
                isMobile: isMobile,
                isAndroid: isAndroid,
                isIOS: isIOS,
                hasWebSerial: 'serial' in navigator,
                hasWebBluetooth: 'bluetooth' in navigator,
                hasWebUSB: 'usb' in navigator
            };

            // Show Android-specific instructions
            if (isAndroid) {
                document.getElementById('android-instructions').style.display = 'block';
                document.getElementById('usb-android-warning').style.display = 'block';
            }

            updatePlatformDisplay();
            checkPermissions();
            updateConnectionMethods();
        }

        function updatePlatformDisplay() {
            const platformElement = document.getElementById('platform-detected');
            const capabilitiesElement = document.getElementById('platform-capabilities');
            
            platformElement.textContent = `üì± Platform: ${platform.name}`;
            
            let capabilities = [];
            if (platform.hasWebSerial) capabilities.push('USB ANT+');
            if (platform.hasWebBluetooth) capabilities.push('Bluetooth');
            if (platform.hasWebUSB) capabilities.push('WebUSB');
            
            if (capabilities.length > 0) {
                capabilitiesElement.textContent = `‚úÖ Available APIs: ${capabilities.join(', ')}`;
                capabilitiesElement.style.color = '#27ae60';
            } else {
                capabilitiesElement.textContent = '‚ùå Limited connectivity options available';
                capabilitiesElement.style.color = '#e74c3c';
            }
        }

        // Permission checking and requesting
        async function checkPermissions() {
            // Check HTTPS
            permissionStatus.https = location.protocol === 'https:' || location.hostname === 'localhost';
            updatePermissionDisplay('https-status', 'https-indicator', permissionStatus.https);

            // Check Web Bluetooth API
            permissionStatus.webBluetooth = 'bluetooth' in navigator;
            updatePermissionDisplay('bluetooth-api-status', 'bluetooth-api-indicator', permissionStatus.webBluetooth);

            // Check location permission (required for Bluetooth on Android)
            if (platform.isAndroid && 'permissions' in navigator) {
                document.getElementById('location-status').style.display = 'flex';
                try {
                    const result = await navigator.permissions.query({name: 'geolocation'});
                    permissionStatus.location = result.state;
                    updatePermissionDisplay('location-status', 'location-indicator', result.state === 'granted');
                    
                    if (result.state === 'prompt') {
                        document.getElementById('request-location-btn').style.display = 'inline-block';
                    }
                } catch (error) {
                    log('‚ö†Ô∏è Could not check location permission status');
                    permissionStatus.location = 'unknown';
                    updatePermissionDisplay('location-status', 'location-indicator', null);
                }
            }

            updateConnectionMethods();
        }

        function updatePermissionDisplay(itemId, indicatorId, granted) {
            const item = document.getElementById(itemId);
            const indicator = document.getElementById(indicatorId);
            
            if (granted === true) {
                item.className = 'permission-item permission-granted';
                indicator.textContent = '‚úÖ';
            } else if (granted === false) {
                item.className = 'permission-item permission-denied';
                indicator.textContent = '‚ùå';
            } else {
                item.className = 'permission-item permission-unknown';
                indicator.textContent = '‚ùì';
            }
        }

        async function requestLocationPermission() {
            try {
                await navigator.geolocation.getCurrentPosition(() => {}, () => {});
                const result = await navigator.permissions.query({name: 'geolocation'});
                permissionStatus.location = result.state;
                updatePermissionDisplay('location-status', 'location-indicator', result.state === 'granted');
                document.getElementById('request-location-btn').style.display = 'none';
                updateConnectionMethods();
                log('‚úÖ Location permission granted');
            } catch (error) {
                log(`‚ùå Location permission denied: ${error.message}`);
            }
        }

        function updateConnectionMethods() {
            const usbMethod = document.getElementById('usb-method');
            const bluetoothMethod = document.getElementById('bluetooth-method');
            const usbBtn = document.getElementById('usb-connect-btn');
            const bluetoothBtn = document.getElementById('bluetooth-connect-btn');
            const scanKickrBtn = document.getElementById('scan-kickr-btn');
            const scanZwiftBtn = document.getElementById('scan-zwift-btn');
            const scanHrmBtn = document.getElementById('scan-hrm-btn');
            
            // USB ANT+ Method (not available on Android)
            if (platform.hasWebSerial && !platform.isMobile) {
                usbMethod.classList.add('available');
                usbBtn.disabled = false;
                log('‚úÖ USB ANT+ stick connection available');
            } else {
                usbMethod.classList.add('unavailable');
                usbBtn.disabled = true;
                if (platform.isAndroid) {
                    log('‚ÑπÔ∏è USB ANT+ not supported on Android');
                } else if (platform.isMobile) {
                    log('‚ÑπÔ∏è USB ANT+ not available on mobile devices');
                } else {
                    log('‚ùå Web Serial API not supported in this browser');
                }
            }
            
            // Bluetooth Method
            const bluetoothAvailable = platform.hasWebBluetooth && 
                                       permissionStatus.https && 
                                       (!platform.isAndroid || permissionStatus.location === 'granted');
            
            if (bluetoothAvailable) {
                bluetoothMethod.classList.add('available');
                bluetoothBtn.disabled = false;
                scanKickrBtn.disabled = false;
                scanZwiftBtn.disabled = false;
                scanHrmBtn.disabled = false;
                log('‚úÖ Bluetooth ANT+ connection available');
            } else {
                bluetoothMethod.classList.add('unavailable');
                bluetoothBtn.disabled = true;
                scanKickrBtn.disabled = true;
                scanZwiftBtn.disabled = true;
                scanHrmBtn.disabled = true;
                
                if (!platform.hasWebBluetooth) {
                    log('‚ùå Web Bluetooth API not supported');
                } else if (!permissionStatus.https) {
                    log('‚ùå HTTPS required for Bluetooth on mobile');
                } else if (platform.isAndroid && permissionStatus.location !== 'granted') {
                    log('‚ùå Location permission required for Bluetooth on Android');
                }
            }

            updatePermissionDisplay('bluetooth-status', 'bluetooth-indicator', bluetoothAvailable);
        }

        // USB Connection (Desktop only)
        async function connectUSB() {
            if (!platform.hasWebSerial) {
                alert('Web Serial API not supported on this platform');
                return;
            }

            try {
                const port = await navigator.serial.requestPort();
                await port.open({ baudRate: 57600 });
                
                currentConnection = {
                    type: 'usb',
                    port: port,
                    reader: null
                };
                
                updateConnectionStatus('Connected via USB ANT+', 'success');
                log('üîå USB ANT+ stick connected successfully');
                
                // Start listening for data
                startUSBListening();
                
            } catch (error) {
                log(`‚ùå USB connection failed: ${error.message}`);
                updateConnectionStatus('USB connection failed', 'error');
            }
        }

        async function startUSBListening() {
            if (!currentConnection || currentConnection.type !== 'usb') return;
            
            try {
                const reader = currentConnection.port.readable.getReader();
                currentConnection.reader = reader;
                
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    
                    processANTData(value);
                }
            } catch (error) {
                log(`‚ùå USB reading error: ${error.message}`);
            }
        }

        // Bluetooth Connection with Android-specific handling
        async function connectBluetooth() {
            if (!platform.hasWebBluetooth) {
                alert('Web Bluetooth API not supported on this platform');
                return;
            }

            if (platform.isAndroid && permissionStatus.location !== 'granted') {
                alert('Location permission is required for Bluetooth scanning on Android. Please grant location permission first.');
                return;
            }

            try {
                log('üîç Scanning for Bluetooth ANT+ devices...');
                
                const device = await navigator.bluetooth.requestDevice({
                    filters: [
                        { services: ['heart_rate'] },
                        { services: ['cycling_power'] },
                        { services: ['cycling_speed_and_cadence'] },
                        { services: ['fitness_equipment'] },
                        { namePrefix: 'KICKR' },
                        { namePrefix: 'SNAP' },
                        { namePrefix: 'Wahoo' },
                        { namePrefix: 'Garmin' },
                        { namePrefix: 'Polar' }
                    ],
                    optionalServices: [
                        'device_information',
                        'battery_service',
                        'generic_access',
                        '6e40fec1-b5a3-f393-e0a9-e50e24dcca9e' // Wahoo custom service
                    ]
                });

                log(`üì± Found device: ${device.name || 'Unknown Device'}`);
                
                const server = await device.gatt.connect();
                
                currentConnection = {
                    type: 'bluetooth',
                    device: device,
                    server: server
                };
                
                updateConnectionStatus(`Connected to ${device.name || 'Bluetooth Device'}`, 'success');
                
                // Start monitoring services
                await startBluetoothMonitoring();
                
            } catch (error) {
                log(`‚ùå Bluetooth connection failed: ${error.message}`);
                if (error.message.includes('User cancelled')) {
                    updateConnectionStatus('Connection cancelled by user', 'warning');
                } else {
                    updateConnectionStatus('Bluetooth connection failed', 'error');
                }
            }
        }

        // Specific device scanning functions
        async function scanHeartRateMonitors() {
            if (!checkBluetoothRequirements()) return;

            try {
                log('üîç Scanning specifically for Heart Rate Monitors...');
                
                const device = await navigator.bluetooth.requestDevice({
                    filters: [
                        { services: ['heart_rate'] },
                        { namePrefix: 'Polar' },
                        { namePrefix: 'Garmin' },
                        { namePrefix: 'Wahoo' }
                    ],
                    optionalServices: ['device_information', 'battery_service']
                });

                await connectToDevice(device, 'Heart Rate Monitor');
                
            } catch (error) {
                handleBluetoothError(error, 'Heart Rate Monitor');
            }
        }

        async function scanTrainers() {
            if (!checkBluetoothRequirements()) return;

            try {
                log('üîç Scanning specifically for Smart Trainers...');
                
                const device = await navigator.bluetooth.requestDevice({
                    filters: [
                        { services: ['fitness_equipment'] },
                        { services: ['cycling_power'] },
                        { namePrefix: 'KICKR' },
                        { namePrefix: 'SNAP' },
                        { namePrefix: 'Wahoo' },
                        { namePrefix: 'Tacx' },
                        { namePrefix: 'Elite' }
                    ],
                    optionalServices: [
                        'fitness_equipment',
                        'cycling_power',
                        'cycling_speed_and_cadence',
                        'device_information',
                        '6e40fec1-b5a3-f393-e0a9-e50e24dcca9e'
                    ]
                });

                await connectToDevice(device, 'Smart Trainer');
                
            } catch (error) {
                handleBluetoothError(error, 'Smart Trainer');
            }
        }

        function checkBluetoothRequirements() {
            if (!platform.hasWebBluetooth) {
                alert('Web Bluetooth API not supported on this platform');
                return false;
            }

            if (platform.isAndroid && permissionStatus.location !== 'granted') {
                alert('Location permission is required for Bluetooth scanning on Android. Please grant location permission first.');
                return false;
            }

            if (!permissionStatus.https) {
                alert('HTTPS connection is required for Bluetooth on mobile devices');
                return false;
            }

            return true;
        }

        async function connectToDevice(device, deviceType) {
            log(`üì± Found ${deviceType}: ${device.name || 'Unknown'}`);
            
            const server = await device.gatt.connect();
            
            currentConnection = {
                type: 'bluetooth',
                device: device,
                server: server,
                deviceType: deviceType
            };
            
            updateConnectionStatus(`Connected to ${device.name || deviceType}`, 'success');
            await startBluetoothMonitoring();
        }

        function handleBluetoothError(error, deviceType) {
            log(`‚ùå ${deviceType} connection failed: ${error.message}`);
            
            if (error.message.includes('User cancelled')) {
                updateConnectionStatus(`${deviceType} scan cancelled`, 'warning');
            } else if (error.message.includes('not found')) {
                updateConnectionStatus(`No ${deviceType} devices found`, 'warning');
            } else {
                updateConnectionStatus(`${deviceType} connection failed`, 'error');
            }
        }

        async function startBluetoothMonitoring() {
            if (!currentConnection || currentConnection.type !== 'bluetooth') return;
            
            try {
                const server = currentConnection.server;
                const deviceName = currentConnection.device.name || '';
                
                // Monitor Heart Rate
                try {
                    const hrService = await server.getPrimaryService('heart_rate');
                    const hrCharacteristic = await hrService.getCharacteristic('heart_rate_measurement');
                    await hrCharacteristic.startNotifications();
                    hrCharacteristic.addEventListener('characteristicvaluechanged', handleHeartRateData);
                    log('‚ù§Ô∏è Heart Rate monitoring started');
                } catch (e) {
                    log('‚ÑπÔ∏è Heart Rate service not available');
                }
                
                // Monitor Cycling Power
                try {
                    const powerService = await server.getPrimaryService('cycling_power');
                    const powerCharacteristic = await powerService.getCharacteristic('cycling_power_measurement');
                    await powerCharacteristic.startNotifications();
                    powerCharacteristic.addEventListener('characteristicvaluechanged', handlePowerData);
                    log('‚ö° Power monitoring started');
                } catch (e) {
                    log('‚ÑπÔ∏è Cycling Power service not available');
                }
                
                // Monitor Fitness Equipment (for trainers)
                try {
                    const ftmsService = await server.getPrimaryService('fitness_equipment');
                    const ftmsCharacteristic = await ftmsService.getCharacteristic('indoor_bike_data');
                    await ftmsCharacteristic.startNotifications();
                    ftmsCharacteristic.addEventListener('characteristicvaluechanged', handleTrainerData);
                    log('üö¥ Trainer data monitoring started');
                } catch (e) {
                    log('‚ÑπÔ∏è Fitness Equipment service not available');
                }
                
                // Monitor Speed/Cadence (including Zwift Click button presses)
                try {
                    const cscService = await server.getPrimaryService('cycling_speed_and_cadence');
                    const cscCharacteristic = await cscService.getCharacteristic('csc_measurement');
                    await cscCharacteristic.startNotifications();
                    cscCharacteristic.addEventListener('characteristicvaluechanged', handleSpeedCadenceData);
                    log('üö¥ Speed/Cadence monitoring started');
                    
                    // If this is a Zwift Click, also monitor for button presses
                    if (deviceName.toLowerCase().includes('click')) {
                        // Try to find Zwift Click specific characteristics
                        try {
                            const zwiftService = await server.getPrimaryService('6e40fec1-b5a3-f393-e0a9-e50e24dcca9e');
                            const zwiftCharacteristic = await zwiftService.getCharacteristic('6e40fec2-b5a3-f393-e0a9-e50e24dcca9e');
                            await zwiftCharacteristic.startNotifications();
                            zwiftCharacteristic.addEventListener('characteristicvaluechanged', handleZwiftClickCustomData);
                            log('‚ö° Zwift Click button monitoring started');
                        } catch (e) {
                            log('‚ÑπÔ∏è Zwift Click button service not available, trying generic button service');
                            
                            // Try generic button service
                            try {
                                const buttonService = await server.getPrimaryService('00001812-0000-1000-8000-00805f9b34fb'); // HID service
                                const buttonCharacteristic = await buttonService.getCharacteristic('00002a4d-0000-1000-8000-00805f9b34fb'); // Report characteristic
                                await buttonCharacteristic.startNotifications();
                                buttonCharacteristic.addEventListener('characteristicvaluechanged', handleZwiftClickHIDReport);
                                log('‚ö° Generic button monitoring started for Zwift Click');
                            } catch (e2) {
                                log('‚ÑπÔ∏è No button service found, will detect shifts from speed/cadence changes');
                            }
                        }
                    }
                } catch (e) {
                    log('‚ÑπÔ∏è Speed/Cadence service not available');
                }
                
                // Monitor Custom Services (for specific device features)
                try {
                    // Wahoo custom service
                    if (deviceName.toLowerCase().includes('kickr') || deviceName.toLowerCase().includes('wahoo')) {
                        const wahooService = await server.getPrimaryService('6e40fec1-b5a3-f393-e0a9-e50e24dcca9e');
                        const wahooCharacteristic = await wahooService.getCharacteristic('6e40fec2-b5a3-f393-e0a9-e50e24dcca9e');
                        await wahooCharacteristic.startNotifications();
                        wahooCharacteristic.addEventListener('characteristicvaluechanged', handleWahooCustomData);
                        log('üö¥ Wahoo custom service monitoring started');
                    }
                } catch (e) {
                    log('‚ÑπÔ∏è Custom device services not available');
                }
                
            } catch (error) {
                log(`‚ùå Bluetooth monitoring setup failed: ${error.message}`);
            }
        }

        // Data Handlers (same as before but with better error handling)
        function handleHeartRateData(event) {
            try {
                const value = event.target.value;
                const heartRate = value.getUint8(1);
                
                updateHRMMetrics({
                    heartRate: heartRate,
                    source: 'bluetooth'
                });
                
                log(`‚ù§Ô∏è HR: ${heartRate} BPM`);
            } catch (error) {
                log(`‚ùå Error parsing heart rate data: ${error.message}`);
            }
        }

        function handlePowerData(event) {
            try {
                const value = event.target.value;
                const flags = value.getUint16(0, true);
                const power = value.getUint16(2, true);
                
                let cadence = 0;
                if (flags & 0x20 && value.byteLength >= 6) {
                    cadence = value.getUint8(5);
                }
                
                updateTrainerMetrics({
                    power: power,
                    cadence: cadence,
                    speed: (power / 10).toFixed(1),
                    resistance: Math.round(power / 20),
                    source: 'bluetooth'
                });
                
                log(`‚ö° Power: ${power}W, Cadence: ${cadence}RPM`);
            } catch (error) {
                log(`‚ùå Error parsing power data: ${error.message}`);
            }
        }

        function handleTrainerData(event) {
            try {
                const value = event.target.value;
                const flags = value.getUint16(0, true);
                let offset = 2;
                
                let power = 0, cadence = 0, speed = 0, resistance = 0;
                
                if (flags & 0x01) {
                    speed = value.getUint16(offset, true) / 100;
                    offset += 2;
                }
                
                if (flags & 0x08) {
                    cadence = value.getUint16(offset, true) / 2;
                    offset += 2;
                }
                
                if (flags & 0x40) {
                    power = value.getInt16(offset, true);
                    offset += 2;
                }
                
                if (flags & 0x200) {
                    resistance = value.getInt16(offset, true);
                }
                
                updateTrainerMetrics({
                    power: power,
                    cadence: cadence,
                    speed: speed.toFixed(1),
                    resistance: resistance,
                    source: 'trainer'
                });
                
                log(`üö¥ Trainer: ${power}W, ${cadence}RPM, ${speed.toFixed(1)}km/h`);
            } catch (error) {
                log(`‚ùå Error parsing trainer data: ${error.message}`);
            }
        }

        function handleSpeedCadenceData(event) {
            try {
                const value = event.target.value;
                const flags = value.getUint8(0);
                
                let cadence = 0, speed = 0;
                
                if (flags & 0x01) {
                    const wheelRevs = value.getUint32(1, true);
                    const wheelTime = value.getUint16(5, true);
                    speed = (wheelRevs * 2.1 * 3.6 / 1000).toFixed(1);
                }
                
                if (flags & 0x02) {
                    const crankRevs = value.getUint16(7, true);
                    cadence = Math.round(crankRevs / 60);
                }
                
                updateTrainerMetrics({
                    power: 0,
                    cadence: cadence,
                    speed: speed,
                    resistance: 0,
                    source: 'bluetooth'
                });
                
                log(`üö¥ Speed: ${speed}km/h, Cadence: ${cadence}RPM`);
            } catch (error) {
                log(`‚ùå Error parsing speed/cadence data: ${error.message}`);
            }
        }

        // UI Update Functions (same as before)
        function updateTrainerMetrics(data) {
            document.getElementById('power-value').textContent = data.power || '---';
            document.getElementById('cadence-value').textContent = data.cadence || '---';
            document.getElementById('speed-value').textContent = data.speed || '---';
            document.getElementById('resistance-value').textContent = data.resistance || '---';
            
            if (!sessionData.trainer.startTime && data.power > 0) {
                sessionData.trainer.startTime = Date.now();
            }
            
            if (sessionData.trainer.startTime) {
                const elapsedTime = Date.now() - sessionData.trainer.startTime;
                const speedKmh = parseFloat(data.speed) || 0;
                sessionData.trainer.distance += speedKmh * (1000 / 3600000);
                
                document.getElementById('distance-value').textContent = sessionData.trainer.distance.toFixed(2);
                document.getElementById('time-value').textContent = formatTime(elapsedTime);
            }
            
            updateDeviceStatus('trainer', 'receiving');
            animateMetricUpdate('power-metric');
            document.getElementById('trainer-last-update').textContent = `Last update: ${new Date().toLocaleTimeString()}`;
        }

        function updateHRMMetrics(data) {
            document.getElementById('hr-value').textContent = data.heartRate;
            
            sessionData.hrm.hrHistory.push(data.heartRate);
            if (sessionData.hrm.hrHistory.length > 20) {
                sessionData.hrm.hrHistory.shift();
            }
            
            const avgHR = sessionData.hrm.hrHistory.reduce((a, b) => a + b, 0) / sessionData.hrm.hrHistory.length;
            document.getElementById('hr-avg').textContent = Math.round(avgHR);
            
            if (data.heartRate > sessionData.hrm.maxHR) {
                sessionData.hrm.maxHR = data.heartRate;
            }
            document.getElementById('hr-max').textContent = sessionData.hrm.maxHR;
            
            updateHRZone(data.heartRate);
            updateDeviceStatus('hrm', 'receiving');
            animateMetricUpdate('hr-metric');
            document.getElementById('hrm-last-update').textContent = `Last update: ${new Date().toLocaleTimeString()}`;
        }

        function updateHRZone(heartRate) {
            const maxHR = 185;
            const zoneElement = document.getElementById('hr-zone');
            
            const zones = [
                { max: 0.6, name: 'Zone 1 - Recovery', class: 'zone-1' },
                { max: 0.7, name: 'Zone 2 - Aerobic Base', class: 'zone-2' },
                { max: 0.8, name: 'Zone 3 - Aerobic', class: 'zone-3' },
                { max: 0.9, name: 'Zone 4 - Threshold', class: 'zone-4' },
                { max: 1.0, name: 'Zone 5 - VO2 Max', class: 'zone-5' }
            ];
            
            const hrPercent = heartRate / maxHR;
            let currentZone = zones[zones.length - 1];
            
            for (let zone of zones) {
                if (hrPercent <= zone.max) {
                    currentZone = zone;
                    break;
                }
            }
            
            zoneElement.textContent = currentZone.name;
            zoneElement.className = `hr-zone ${currentZone.class}`;
        }

        function updateDeviceStatus(device, status) {
            const statusIndicator = document.getElementById(`${device}-status`);
            const statusText = document.getElementById(`${device}-status-text`);
            const card = document.getElementById(`${device}-card`);
            
            switch (status) {
                case 'receiving':
                    statusIndicator.className = 'status-indicator status-active';
                    statusText.textContent = 'Receiving Data';
                    card.classList.add('receiving');
                    break;
                case 'searching':
                    statusIndicator.className = 'status-indicator status-searching';
                    statusText.textContent = 'Searching...';
                    card.classList.remove('receiving');
                    break;
                default:
                    statusIndicator.className = 'status-indicator status-inactive';
                    statusText.textContent = 'No Signal';
                    card.classList.remove('receiving');
                    break;
            }
        }

        function updateConnectionStatus(message, type) {
            const statusDiv = document.getElementById('connection-status');
            const statusText = document.getElementById('status-text');
            
            statusDiv.style.display = 'block';
            statusText.textContent = message;
            
            if (type === 'success') {
                statusDiv.style.background = '#d4edda';
                statusDiv.style.color = '#155724';
                statusDiv.style.border = '1px solid #c3e6cb';
            } else if (type === 'error') {
                statusDiv.style.background = '#f8d7da';
                statusDiv.style.color = '#721c24';
                statusDiv.style.border = '1px solid #f5c6cb';
            } else {
                statusDiv.style.background = '#fff3cd';
                statusDiv.style.color = '#856404';
                statusDiv.style.border = '1px solid #ffeaa7';
            }
        }

        function animateMetricUpdate(metricId) {
            const metric = document.getElementById(metricId);
            metric.classList.add('updated');
            setTimeout(() => metric.classList.remove('updated'), 300);
        }

        function formatTime(milliseconds) {
            const totalSeconds = Math.floor(milliseconds / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function log(message) {
            const logContent = document.getElementById('log-content');
            const timestamp = new Date().toLocaleTimeString();
            logContent.textContent += `[${timestamp}] ${message}\n`;
            logContent.scrollTop = logContent.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log-content').textContent = '';
        }

        // Device-specific control functions
        let zwiftGear = 4;
        let kickrResistance = 0;
        let kickrTargetPower = 150;

        // Wahoo Kickr Core Functions
        function updateKickrResistance(value) {
            kickrResistance = parseInt(value);
            document.getElementById('kickr-resistance-display').textContent = value;
            
            if (currentConnection && currentConnection.device && currentConnection.device.name && 
                currentConnection.device.name.toLowerCase().includes('kickr')) {
                sendKickrResistanceCommand(kickrResistance);
                log(`üö¥ Kickr resistance set to: ${kickrResistance}%`);
            }
        }

        async function pairKickr() {
            if (!checkBluetoothRequirements()) return;

            try {
                log('üîç Scanning specifically for Wahoo Kickr Core...');
                
                const device = await navigator.bluetooth.requestDevice({
                    filters: [
                        { namePrefix: 'KICKR CORE' },
                        { namePrefix: 'KICKR' },
                        { namePrefix: 'Wahoo' }
                    ],
                    optionalServices: [
                        'fitness_equipment',
                        'cycling_power',
                        'cycling_speed_and_cadence',
                        'device_information',
                        'battery_service',
                        '6e40fec1-b5a3-f393-e0a9-e50e24dcca9e' // Wahoo custom service
                    ]
                });

                await connectToDevice(device, 'Wahoo Kickr Core');

                const server = await device.gatt.connect();
                
                // Store connection
                currentConnection = {
                    type: 'bluetooth',
                    device: device,
                    server: server
                };
                
                // Start monitoring Kickr-specific services
                await startKickrMonitoring(server);
                
                updateDeviceStatus('kickr', 'receiving');
                updateConnectionStatus(`Connected to ${device.name}`, 'success');
                
            } catch (error) {
                handleBluetoothError(error, 'Wahoo Kickr Core');
            }
        }

        function stopKickr() {
            if (currentConnection && currentConnection.device && 
                currentConnection.device.name && currentConnection.device.name.toLowerCase().includes('kickr')) {
                currentConnection.device.gatt.disconnect();
                updateDeviceStatus('kickr', 'inactive');
                updateConnectionStatus('Kickr Core disconnected', 'warning');
                log('üö¥ Wahoo Kickr Core disconnected');
            }
        }

        function sendKickrResistanceCommand(resistance) {
            if (!currentConnection || !currentConnection.controlCharacteristic) {
                log('‚ùå No Kickr control connection available');
                return;
            }
            
            try {
                // FTMS Set Target Resistance Level command
                const command = new Uint8Array([
                    0x11, // Set Target Resistance Level opcode
                    resistance // Resistance level (0-100%)
                ]);
                
                currentConnection.controlCharacteristic.writeValue(command);
                log(`üì§ Kickr resistance set to ${resistance}%`);
                
            } catch (error) {
                log(`‚ùå Failed to set Kickr resistance: ${error.message}`);
            }
        }

        // New Kickr-specific monitoring function
        async function startKickrMonitoring(server) {
            try {
                // Try Fitness Equipment service first (primary for trainers)
                try {
                    const ftmsService = await server.getPrimaryService('fitness_equipment');
                    
                    // Indoor Bike Data characteristic
                    try {
                        const indoorBikeChar = await ftmsService.getCharacteristic('indoor_bike_data');
                        await indoorBikeChar.startNotifications();
                        indoorBikeChar.addEventListener('characteristicvaluechanged', handleKickrIndoorBikeData);
                        log('üö¥ Kickr Indoor Bike Data monitoring started');
                    } catch (e) {
                        log('‚ÑπÔ∏è Indoor Bike Data not available');
                    }
                    
                    // Fitness Machine Control Point
                    try {
                        const controlChar = await ftmsService.getCharacteristic('fitness_machine_control_point');
                        // Store for sending commands
                        currentConnection.controlCharacteristic = controlChar;
                        log('üéÆ Kickr Control Point available');
                    } catch (e) {
                        log('‚ÑπÔ∏è Control Point not available');
                    }
                    
                } catch (e) {
                    log('‚ÑπÔ∏è Fitness Equipment service not available');
                }
                
                // Try Cycling Power service as backup
                try {
                    const powerService = await server.getPrimaryService('cycling_power');
                    const powerChar = await powerService.getCharacteristic('cycling_power_measurement');
                    await powerChar.startNotifications();
                    powerChar.addEventListener('characteristicvaluechanged', handleKickrPowerData);
                    log('‚ö° Kickr Power monitoring started');
                } catch (e) {
                    log('‚ÑπÔ∏è Cycling Power service not available');
                }
                
                // Try Wahoo custom service
                try {
                    const wahooService = await server.getPrimaryService('6e40fec1-b5a3-f393-e0a9-e50e24dcca9e');
                    const wahooChar = await wahooService.getCharacteristic('6e40fec2-b5a3-f393-e0a9-e50e24dcca9e');
                    await wahooChar.startNotifications();
                    wahooChar.addEventListener('characteristicvaluechanged', handleKickrWahooData);
                    log('üîß Kickr Wahoo service monitoring started');
                } catch (e) {
                    log('‚ÑπÔ∏è Wahoo custom service not available');
                }
                
            } catch (error) {
                log(`‚ùå Kickr monitoring setup failed: ${error.message}`);
            }
        }

        // Improved Kickr data handlers
        function handleKickrIndoorBikeData(event) {
            try {
                const data = event.target.value;
                const flags = data.getUint16(0, true);
                let offset = 2;
                
                let metrics = { power: 0, cadence: 0, speed: 0, resistance: 0 };
                
                // Parse based on flags
                if (flags & 0x01) { // More data available
                    // Skip reserved byte
                    offset += 1;
                }
                
                if (flags & 0x04) { // Speed present
                    metrics.speed = (data.getUint16(offset, true) / 100).toFixed(1);
                    offset += 2;
                }
                
                if (flags & 0x08) { // Cadence present
                    metrics.cadence = Math.round(data.getUint16(offset, true) / 2);
                    offset += 2;
                }
                
                if (flags & 0x40) { // Power present
                    metrics.power = data.getInt16(offset, true);
                    offset += 2;
                }
                
                if (flags & 0x200) { // Resistance present
                    metrics.resistance = data.getInt16(offset, true);
                }
                
                updateKickrMetrics(metrics);
                log(`üö¥ Kickr: ${metrics.power}W, ${metrics.cadence}RPM, ${metrics.speed}km/h`);
                
            } catch (error) {
                log(`‚ùå Error parsing Kickr indoor bike data: ${error.message}`);
            }
        }

        function handleKickrPowerData(event) {
            try {
                const data = event.target.value;
                const flags = data.getUint16(0, true);
                const power = data.getUint16(2, true);
                
                let cadence = 0;
                if (flags & 0x20 && data.byteLength >= 8) {
                    cadence = data.getUint8(7);
                }
                
                updateKickrMetrics({
                    power: power,
                    cadence: cadence,
                    speed: (power * 0.036).toFixed(1), // Rough speed calculation
                    resistance: Math.round(power / 20)
                });
                
            } catch (error) {
                log(`‚ùå Error parsing Kickr power data: ${error.message}`);
            }
        }

        function handleKickrWahooData(event) {
            try {
                const data = event.target.value;
                // Wahoo custom data parsing would go here
                log(`üîß Wahoo custom data received: ${data.byteLength} bytes`);
            } catch (error) {
                log(`‚ùå Error parsing Wahoo custom data: ${error.message}`);
            }
        }

        // Zwift Click HID functions
        async function startZwiftClickHIDMonitoring(server) {
            try {
                // Try HID service for real button detection
                const hidService = await server.getPrimaryService('00001812-0000-1000-8000-00805f9b34fb');
                
                // HID Report characteristic
                const reportChar = await hidService.getCharacteristic('00002a4d-0000-1000-8000-00805f9b34fb');
                await reportChar.startNotifications();
                reportChar.addEventListener('characteristicvaluechanged', handleZwiftClickHIDReport);
                log('‚ö° Zwift Click HID monitoring started');
                
            } catch (error) {
                log(`‚ùå Zwift Click HID setup failed: ${error.message}`);
                
                // Fallback to manufacturer-specific service
                try {
                    log('üîÑ Trying manufacturer-specific service...');
                    const customService = await server.getPrimaryService('6e40fec1-b5a3-f393-e0a9-e50e24dcca9e');
                    const customChar = await customService.getCharacteristic('6e40fec2-b5a3-f393-e0a9-e50e24dcca9e');
                    await customChar.startNotifications();
                    customChar.addEventListener('characteristicvaluechanged', handleZwiftClickCustomData);
                    log('‚ö° Zwift Click custom service monitoring started');
                } catch (e2) {
                    log(`‚ùå No suitable Zwift Click service found: ${e2.message}`);
                }
            }
        }

        function handleZwiftClickHIDReport(event) {
            try {
                const data = event.target.value;
                const reportData = new Uint8Array(data.buffer);
                
                log(`‚ö° HID Report: ${Array.from(reportData).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
                
                // Parse button press reports
                if (reportData.length >= 2) {
                    const buttonState = reportData[1];
                    
                    // Check for button presses
                    if (buttonState & 0x01) { // Right button (shift up)
                        zwiftShiftUp();
                        log('‚ö° Zwift Click: Right button pressed (shift up)');
                    }
                    
                    if (buttonState & 0x02) { // Left button (shift down)
                        zwiftShiftDown();
                        log('‚ö° Zwift Click: Left button pressed (shift down)');
                    }
                }
                
            } catch (error) {
                log(`‚ùå Error parsing Zwift Click HID report: ${error.message}`);
            }
        }

        function handleZwiftClickCustomData(event) {
            try {
                const data = event.target.value;
                const customData = new Uint8Array(data.buffer);
                
                log(`‚ö° Custom Data: ${Array.from(customData).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
                
                // Parse custom Zwift Click protocol
                if (customData.length >= 1) {
                    const command = customData[0];
                    
                    switch (command) {
                        case 0x01: // Shift up
                            zwiftShiftUp();
                            break;
                        case 0x02: // Shift down
                            zwiftShiftDown();
                            break;
                        default:
                            log(`‚ö° Unknown Zwift Click command: 0x${command.toString(16)}`);
                    }
                }
                
            } catch (error) {
                log(`‚ùå Error parsing Zwift Click custom data: ${error.message}`);
            }
        }

        // Zwift Click Functions
        function zwiftShiftUp() {
            if (zwiftGear < 12) {
                zwiftGear++;
                document.getElementById('zwift-gear').textContent = zwiftGear;
                updateZwiftGearing();
                log(`‚ö° Zwift Click: Shifted up to gear ${zwiftGear}`);
                
                if (currentConnection && currentConnection.device && 
                    currentConnection.device.name && currentConnection.device.name.toLowerCase().includes('click')) {
                    sendZwiftShiftCommand('up');
                }
            }
        }

        function zwiftShiftDown() {
            if (zwiftGear > 1) {
                zwiftGear--;
                document.getElementById('zwift-gear').textContent = zwiftGear;
                updateZwiftGearing();
                log(`‚ö° Zwift Click: Shifted down to gear ${zwiftGear}`);
                
                if (currentConnection && currentConnection.device && 
                    currentConnection.device.name && currentConnection.device.name.toLowerCase().includes('click')) {
                    sendZwiftShiftCommand('down');
                }
            }
        }

        function updateZwiftGearing() {
            // Simulate front/rear gear calculations based on current gear
            const gearRatios = [
                {front: 50, rear: 28}, {front: 50, rear: 25}, {front: 50, rear: 23}, {front: 50, rear: 21},
                {front: 50, rear: 19}, {front: 50, rear: 17}, {front: 50, rear: 15}, {front: 50, rear: 14},
                {front: 50, rear: 13}, {front: 50, rear: 12}, {front: 50, rear: 11}, {front: 50, rear: 10}
            ];
            
            if (zwiftGear <= gearRatios.length) {
                const ratio = gearRatios[zwiftGear - 1];
                document.getElementById('zwift-front-gear').textContent = ratio.front;
                document.getElementById('zwift-rear-gear').textContent = ratio.rear;
            }
        }

        async function pairZwiftClick() {
            if (!checkBluetoothRequirements()) return;

            try {
                log('üîç Scanning specifically for Zwift Click...');
                
                const device = await navigator.bluetooth.requestDevice({
                    filters: [
                        { namePrefix: 'Zwift Click' },
                        { namePrefix: 'CLICK' },
                        { namePrefix: 'Click' }
                    ],
                    optionalServices: [
                        '00001812-0000-1000-8000-00805f9b34fb', // HID Service
                        'cycling_speed_and_cadence',
                        'device_information',
                        'battery_service',
                        '6e40fec1-b5a3-f393-e0a9-e50e24dcca9e' // Custom service fallback
                    ]
                });

                await connectToDevice(device, 'Zwift Click');
                updateDeviceStatus('zwift', 'receiving');

                // Store connection
                currentConnection = {
                    type: 'bluetooth',
                    device: device,
                    server: server
                };
                
                // Start HID monitoring for real button presses
                await startZwiftClickHIDMonitoring(server);
                
                updateDeviceStatus('zwift', 'receiving');
                updateConnectionStatus(`Connected to ${device.name}`, 'success');
                
            } catch (error) {
                handleBluetoothError(error, 'Zwift Click');
            }
        }

        function stopZwiftClick() {
            if (currentConnection && currentConnection.device && 
                currentConnection.device.name && currentConnection.device.name.toLowerCase().includes('click')) {
                currentConnection.device.gatt.disconnect();
                updateDeviceStatus('zwift', 'inactive');
                updateConnectionStatus('Zwift Click disconnected', 'warning');
                log('‚ö° Zwift Click disconnected');
            }
        }

        function sendZwiftShiftCommand(direction) {
            // This would send the actual shift command to the Zwift Click
            log(`üì§ Sending shift command: ${direction}`);
        }

        // Heart Rate Monitor Functions
        async function pairHRM() {
            if (!checkBluetoothRequirements()) return;

            try {
                log('üîç Scanning specifically for Heart Rate Monitors...');
                
                const device = await navigator.bluetooth.requestDevice({
                    filters: [
                        { services: ['heart_rate'] },
                        { namePrefix: 'Polar' },
                        { namePrefix: 'Garmin' },
                        { namePrefix: 'Wahoo' },
                        { namePrefix: 'TICKR' }
                    ],
                    optionalServices: ['device_information', 'battery_service']
                });

                await connectToDevice(device, 'Heart Rate Monitor');
                updateDeviceStatus('hrm', 'receiving');
                
            } catch (error) {
                handleBluetoothError(error, 'Heart Rate Monitor');
            }
        }

        function stopHRM() {
            if (currentConnection && currentConnection.type === 'bluetooth') {
                currentConnection.device.gatt.disconnect();
                updateDeviceStatus('hrm', 'inactive');
                updateConnectionStatus('Heart Rate Monitor disconnected', 'warning');
                log('‚ù§Ô∏è Heart Rate Monitor disconnected');
            }
        }

        // Enhanced device status update for multiple devices
        function updateDeviceStatus(deviceType, status) {
            const statusIndicator = document.getElementById(`${deviceType}-status`);
            const statusText = document.getElementById(`${deviceType}-status-text`);
            const card = document.getElementById(`${deviceType}-card`) || 
                         document.getElementById(`${deviceType === 'trainer' ? 'kickr' : deviceType}-card`);
            
            if (!statusIndicator || !statusText) return;
            
            switch (status) {
                case 'receiving':
                    statusIndicator.className = 'status-indicator status-active';
                    statusText.textContent = 'Broadcasting';
                    if (card) card.classList.add('receiving');
                    break;
                case 'searching':
                    statusIndicator.className = 'status-indicator status-searching';
                    statusText.textContent = 'Searching...';
                    if (card) card.classList.remove('receiving');
                    break;
                default:
                    statusIndicator.className = 'status-indicator status-inactive';
                    statusText.textContent = 'No Signal';
                    if (card) card.classList.remove('receiving');
                    break;
            }
        }

        // Enhanced data handlers for specific devices
        function updateKickrMetrics(data) {
            document.getElementById('kickr-power-value').textContent = data.power || '---';
            document.getElementById('kickr-cadence-value').textContent = data.cadence || '---';
            document.getElementById('kickr-speed-value').textContent = data.speed || '---';
            document.getElementById('kickr-resistance-value').textContent = data.resistance || '---';
            
            if (!sessionData.trainer.startTime && data.power > 0) {
                sessionData.trainer.startTime = Date.now();
            }
            
            if (sessionData.trainer.startTime) {
                const elapsedTime = Date.now() - sessionData.trainer.startTime;
                const speedKmh = parseFloat(data.speed) || 0;
                sessionData.trainer.distance += speedKmh * (1000 / 3600000);
                
                document.getElementById('kickr-distance-value').textContent = sessionData.trainer.distance.toFixed(2);
                document.getElementById('kickr-time-value').textContent = formatTime(elapsedTime);
            }
            
            updateDeviceStatus('kickr', 'receiving');
            animateMetricUpdate('kickr-power-metric');
            document.getElementById('kickr-last-update').textContent = `Last update: ${new Date().toLocaleTimeString()}`;
        }

        function updateHRMMetrics(data) {
            document.getElementById('hr-current-value').textContent = data.heartRate;
            
            sessionData.hrm.hrHistory.push(data.heartRate);
            if (sessionData.hrm.hrHistory.length > 20) {
                sessionData.hrm.hrHistory.shift();
            }
            
            const avgHR = sessionData.hrm.hrHistory.reduce((a, b) => a + b, 0) / sessionData.hrm.hrHistory.length;
            document.getElementById('hr-avg-value').textContent = Math.round(avgHR);
            
            if (data.heartRate > sessionData.hrm.maxHR) {
                sessionData.hrm.maxHR = data.heartRate;
                document.getElementById('max-hr').textContent = sessionData.hrm.maxHR;
            }
            
            updateHRZone(data.heartRate);
            updateDeviceStatus('hrm', 'receiving');
            animateMetricUpdate('hr-current-metric');
            document.getElementById('hrm-last-update').textContent = `Last update: ${new Date().toLocaleTimeString()}`;
        }

        function updateZwiftClickData(data) {
            if (data.gear !== undefined) {
                zwiftGear = data.gear;
                document.getElementById('zwift-gear').textContent = zwiftGear;
                updateZwiftGearing();
            }
            
            updateDeviceStatus('zwift', 'receiving');
            document.getElementById('zwift-last-update').textContent = `Last update: ${new Date().toLocaleTimeString()}`;
            log(`‚ö° Zwift Click gear: ${zwiftGear}`);
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            detectPlatform();
            updateDeviceStatus('kickr', 'inactive');
            updateDeviceStatus('zwift', 'inactive');
            updateDeviceStatus('hrm', 'inactive');
            
            // Initialize Zwift Click gear display
            updateZwiftGearing();
            
            log('üöÄ Cross-platform ANT+ receiver initialized');
            log(`üì± Platform: ${platform.name}`);
            
            // Additional Android-specific logging
            if (platform.isAndroid) {
                log('üì± Android detected - make sure you\'re using Chrome browser');
                log('üîê HTTPS and location permissions required for Bluetooth');
            }
            
            // Monitor for device disconnections
            if (platform.hasWebBluetooth) {
                // Handle disconnect events
                document.addEventListener('bluetoothdevicedisconnected', (event) => {
                    log('‚ö†Ô∏è Bluetooth device disconnected');
                    updateConnectionStatus('Device disconnected', 'error');
                    currentConnection = null;
                });
            }
        });

        // Improved connection monitoring
        setInterval(() => {
            if (currentConnection && currentConnection.type === 'bluetooth') {
                if (!currentConnection.device.gatt.connected) {
                    log('‚ö†Ô∏è Bluetooth device disconnected');
                    updateConnectionStatus('Device disconnected', 'error');
                    updateDeviceStatus('trainer', 'inactive');
                    updateDeviceStatus('hrm', 'inactive');
                    currentConnection = null;
                }
            }
        }, 5000);

        // Handle visibility change (Android background behavior)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                log('üì± App moved to background');
            } else {
                log('üì± App brought to foreground');
                // Recheck connection status
                if (currentConnection && currentConnection.type === 'bluetooth' && !currentConnection.device.gatt.connected) {
                    log('üîÑ Attempting to reconnect...');
                    currentConnection.device.gatt.connect().then(() => {
                        log('‚úÖ Reconnected successfully');
                        updateConnectionStatus(`Reconnected to ${currentConnection.device.name}`, 'success');
                        startBluetoothMonitoring();
                    }).catch(error => {
                        log(`‚ùå Reconnection failed: ${error.message}`);
                    });
                }
            }
        });
    </script>
</body>
</html>
