<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed Cross-Platform ANT+ Receiver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            min-height: 100vh;
            color: #333;
            padding: 10px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .device-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            opacity: 0.6;
        }

        .device-card.receiving {
            opacity: 1;
            transform: translateY(-2px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
            border: 2px solid #2ecc71;
        }

        .device-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .device-icon {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .device-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .device-status {
            font-size: 0.8rem;
            color: #7f8c8d;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .status-active { background-color: #2ecc71; }
        .status-inactive { background-color: #e74c3c; }
        .status-searching { background-color: #f39c12; animation: pulse 1s infinite; }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .metric {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .metric.updated {
            background: #d4edda;
            transform: scale(1.05);
        }

        .metric-value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .metric-label {
            font-size: 0.7rem;
            color: #7f8c8d;
            text-transform: uppercase;
        }

        .btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
            width: 100%;
            margin: 5px 0;
        }

        .btn:hover {
            background: linear-gradient(45deg, #2980b9, #1f639a);
            transform: translateY(-2px);
        }

        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .btn-stop {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .log-section {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .log-content {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .debug-info {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîß Fixed ANT+ Receiver</h1>
            <p>Proper KICKR Core & Zwift Click Support</p>
        </div>

        <!-- Wahoo Kickr Core Card -->
        <div class="device-card" id="kickr-card">
            <div class="device-header">
                <div class="device-icon" style="background: linear-gradient(45deg, #ff6b6b, #ff8e8e);">üö¥</div>
                <div>
                    <div class="device-title">Wahoo KICKR Core</div>
                    <div class="device-status">
                        <span class="status-indicator" id="kickr-status"></span>
                        <span id="kickr-status-text">No Signal</span>
                    </div>
                    <div style="font-size: 0.7rem; color: #999;" id="kickr-device-info">
                        Device: Not Connected
                    </div>
                </div>
            </div>

            <div class="metrics">
                <div class="metric" id="kickr-power-metric">
                    <div class="metric-value" id="kickr-power-value">---</div>
                    <div class="metric-label">Power (W)</div>
                </div>
                <div class="metric" id="kickr-cadence-metric">
                    <div class="metric-value" id="kickr-cadence-value">---</div>
                    <div class="metric-label">Cadence (RPM)</div>
                </div>
                <div class="metric" id="kickr-speed-metric">
                    <div class="metric-value" id="kickr-speed-value">---</div>
                    <div class="metric-label">Speed (KM/H)</div>
                </div>
                <div class="metric" id="kickr-resistance-metric">
                    <div class="metric-value" id="kickr-resistance-value">---</div>
                    <div class="metric-label">Resistance (%)</div>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button class="btn" onclick="pairKickrCore()">Pair KICKR Core</button>
                <button class="btn btn-stop" onclick="disconnectKickr()">Disconnect</button>
            </div>

            <div id="kickr-last-update" style="text-align: center; font-size: 0.8rem; color: #666; margin-top: 10px;">
                Waiting for connection...
            </div>
        </div>

        <!-- Zwift Click Card -->
        <div class="device-card" id="zwift-card">
            <div class="device-header">
                <div class="device-icon" style="background: linear-gradient(45deg, #28a745, #20c997);">‚ö°</div>
                <div>
                    <div class="device-title">Zwift Click</div>
                    <div class="device-status">
                        <span class="status-indicator" id="zwift-status"></span>
                        <span id="zwift-status-text">No Signal</span>
                    </div>
                    <div style="font-size: 0.7rem; color: #999;" id="zwift-device-info">
                        Device: Not Connected
                    </div>
                </div>
            </div>

            <div style="display: flex; justify-content: center; align-items: center; margin: 20px 0;">
                <div style="text-align: center;">
                    <div style="font-size: 3rem; font-weight: bold; color: #2c3e50;" id="zwift-gear">1</div>
                    <div style="font-size: 0.8rem; color: #666;">Current Gear</div>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px;">
                <div class="metric">
                    <div class="metric-value" id="zwift-button-presses">0</div>
                    <div class="metric-label">Button Events</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="zwift-battery">---</div>
                    <div class="metric-label">Battery %</div>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button class="btn" onclick="pairZwiftClick()">Pair Zwift Click</button>
                <button class="btn btn-stop" onclick="disconnectZwift()">Disconnect</button>
            </div>

            <div id="zwift-last-update" style="text-align: center; font-size: 0.8rem; color: #666; margin-top: 10px;">
                Waiting for connection...
            </div>
        </div>

        <!-- Heart Rate Monitor Card -->
        <div class="device-card" id="hrm-card">
            <div class="device-header">
                <div class="device-icon" style="background: linear-gradient(45deg, #a8e6cf, #7fcdcd);">‚ù§Ô∏è</div>
                <div>
                    <div class="device-title">Heart Rate Monitor</div>
                    <div class="device-status">
                        <span class="status-indicator" id="hrm-status"></span>
                        <span id="hrm-status-text">No Signal</span>
                    </div>
                    <div style="font-size: 0.7rem; color: #999;" id="hrm-device-info">
                        Device: Not Connected
                    </div>
                </div>
            </div>

            <div class="metrics">
                <div class="metric" id="hr-current-metric">
                    <div class="metric-value" id="hr-current-value">---</div>
                    <div class="metric-label">BPM</div>
                </div>
                <div class="metric" id="hr-avg-metric">
                    <div class="metric-value" id="hr-avg-value">---</div>
                    <div class="metric-label">Avg BPM</div>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button class="btn" onclick="pairHRM()">Pair HRM</button>
                <button class="btn btn-stop" onclick="disconnectHRM()">Disconnect</button>
            </div>

            <div id="hrm-last-update" style="text-align: center; font-size: 0.8rem; color: #666; margin-top: 10px;">
                Waiting for connection...
            </div>
        </div>

        <!-- Debug Information -->
        <div class="debug-info" id="debug-info">
            <h4>üîç Debug Information</h4>
            <div id="debug-content">Click "Pair" buttons to start debugging...</div>
        </div>

        <!-- Log Section -->
        <div class="log-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3>üìã Connection Log</h3>
                <button onclick="clearLog()" style="background: #95a5a6; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">Clear</button>
            </div>
            <div class="log-content" id="log-content"></div>
        </div>
    </div>

    <script>
        // Global variables
        let connectedDevices = new Map();
        let zwiftGear = 1;
        let zwiftButtonPresses = 0;

        // Known Bluetooth service UUIDs
        const SERVICES = {
            // Standard BLE services
            HEART_RATE: 'heart_rate',
            CYCLING_POWER: 'cycling_power',
            FITNESS_EQUIPMENT: 'fitness_equipment',
            CYCLING_SPEED_CADENCE: 'cycling_speed_and_cadence',
            DEVICE_INFORMATION: 'device_information',
            BATTERY_SERVICE: 'battery_service',
            
            // Wahoo custom services (these are the actual UUIDs used by KICKR)
            WAHOO_TRAINER: '6e40fec1-b5a3-f393-e0a9-e50e24dcca9e',
            WAHOO_TRAINER_CHAR: '6e40fec2-b5a3-f393-e0a9-e50e24dcca9e',
            
            // Zwift Click services (these need to be discovered)
            HID_SERVICE: '00001812-0000-1000-8000-00805f9b34fb',
            HID_REPORT: '00002a4d-0000-1000-8000-00805f9b34fb'
        };

        // Utility functions
        function log(message) {
            const logContent = document.getElementById('log-content');
            const timestamp = new Date().toLocaleTimeString();
            logContent.textContent += `[${timestamp}] ${message}\n`;
            logContent.scrollTop = logContent.scrollHeight;
            console.log(message);
        }

        function clearLog() {
            document.getElementById('log-content').textContent = '';
        }

        function updateDebugInfo(info) {
            document.getElementById('debug-content').innerHTML = info;
        }

        function updateDeviceStatus(deviceType, status, deviceName = null) {
            const statusIndicator = document.getElementById(`${deviceType}-status`);
            const statusText = document.getElementById(`${deviceType}-status-text`);
            const card = document.getElementById(`${deviceType}-card`);
            const deviceInfo = document.getElementById(`${deviceType}-device-info`);
            
            if (!statusIndicator || !statusText) return;
            
            switch (status) {
                case 'receiving':
                    statusIndicator.className = 'status-indicator status-active';
                    statusText.textContent = 'Connected';
                    if (card) card.classList.add('receiving');
                    if (deviceInfo && deviceName) deviceInfo.textContent = `Device: ${deviceName}`;
                    break;
                case 'searching':
                    statusIndicator.className = 'status-indicator status-searching';
                    statusText.textContent = 'Searching...';
                    if (card) card.classList.remove('receiving');
                    if (deviceInfo) deviceInfo.textContent = 'Scanning for devices...';
                    break;
                default:
                    statusIndicator.className = 'status-indicator status-inactive';
                    statusText.textContent = 'Disconnected';
                    if (card) card.classList.remove('receiving');
                    if (deviceInfo) deviceInfo.textContent = 'Device: Not Connected';
                    break;
            }
        }

        function animateMetricUpdate(metricId) {
            const metric = document.getElementById(metricId);
            if (metric) {
                metric.classList.add('updated');
                setTimeout(() => metric.classList.remove('updated'), 300);
            }
        }

        // Enhanced KICKR Core pairing with proper service discovery
        async function pairKickrCore() {
            if (!navigator.bluetooth) {
                alert('Web Bluetooth is not supported in this browser');
                return;
            }

            try {
                log('üîç Scanning for Wahoo KICKR Core...');
                updateDeviceStatus('kickr', 'searching');
                
                // Try multiple filter strategies for KICKR detection
                const device = await navigator.bluetooth.requestDevice({
                    filters: [
                        { namePrefix: 'KICKR CORE' },
                        { namePrefix: 'KICKR' },
                        { namePrefix: 'Wahoo' },
                        { services: [SERVICES.FITNESS_EQUIPMENT] },
                        { services: [SERVICES.CYCLING_POWER] },
                        { services: [SERVICES.WAHOO_TRAINER] }
                    ],
                    optionalServices: [
                        SERVICES.FITNESS_EQUIPMENT,
                        SERVICES.CYCLING_POWER,
                        SERVICES.CYCLING_SPEED_CADENCE,
                        SERVICES.DEVICE_INFORMATION,
                        SERVICES.BATTERY_SERVICE,
                        SERVICES.WAHOO_TRAINER
                    ]
                });

                log(`üì± Found device: ${device.name || 'Unknown KICKR'}`);
                
                const server = await device.gatt.connect();
                log('üîó Connected to GATT server');
                
                // Store connection
                connectedDevices.set('kickr', {
                    device: device,
                    server: server,
                    type: 'kickr'
                });
                
                updateDeviceStatus('kickr', 'receiving', device.name);
                
                // Discover and log all available services (for debugging)
                await discoverKickrServices(server);
                
                // Start monitoring for data
                await monitorKickrData(server);
                
            } catch (error) {
                log(`‚ùå KICKR Core pairing failed: ${error.message}`);
                updateDeviceStatus('kickr', 'inactive');
                
                if (error.message.includes('User cancelled')) {
                    log('‚ÑπÔ∏è User cancelled device selection');
                } else if (error.message.includes('not found')) {
                    log('‚ÑπÔ∏è No KICKR devices found. Make sure your KICKR Core is in pairing mode');
                } else {
                    log(`üîß Debug: ${error.stack}`);
                }
            }
        }

        async function discoverKickrServices(server) {
            try {
                log('üîç Discovering available services...');
                let debugInfo = '<strong>Available Services:</strong><br>';
                
                // Try to get primary services
                try {
                    const services = await server.getPrimaryServices();
                    debugInfo += `Found ${services.length} services:<br>`;
                    
                    for (let service of services) {
                        const uuid = service.uuid;
                        debugInfo += `‚Ä¢ ${uuid}`;
                        
                        // Add human-readable names for known services
                        if (uuid === '0000180d-0000-1000-8000-00805f9b34fb') debugInfo += ' (Heart Rate)';
                        else if (uuid === '00001818-0000-1000-8000-00805f9b34fb') debugInfo += ' (Cycling Power)';
                        else if (uuid === '00001826-0000-1000-8000-00805f9b34fb') debugInfo += ' (Fitness Equipment)';
                        else if (uuid === '6e40fec1-b5a3-f393-e0a9-e50e24dcca9e') debugInfo += ' (Wahoo Custom)';
                        
                        debugInfo += '<br>';
                        
                        // Try to get characteristics for each service
                        try {
                            const characteristics = await service.getCharacteristics();
                            for (let char of characteristics) {
                                debugInfo += `  ‚îî‚îÄ Characteristic: ${char.uuid}<br>`;
                            }
                        } catch (e) {
                            debugInfo += `  ‚îî‚îÄ Could not read characteristics: ${e.message}<br>`;
                        }
                    }
                } catch (e) {
                    debugInfo += `Error discovering services: ${e.message}<br>`;
                }
                
                updateDebugInfo(debugInfo);
                
            } catch (error) {
                log(`‚ùå Service discovery failed: ${error.message}`);
            }
        }

        async function monitorKickrData(server) {
            try {
                log('üìä Starting KICKR data monitoring...');
                
                // Try Fitness Equipment service first (FTMS protocol)
                try {
                    const ftmsService = await server.getPrimaryService(SERVICES.FITNESS_EQUIPMENT);
                    const indoorBikeChar = await ftmsService.getCharacteristic('indoor_bike_data');
                    
                    await indoorBikeChar.startNotifications();
                    indoorBikeChar.addEventListener('characteristicvaluechanged', handleKickrFTMSData);
                    log('‚úÖ FTMS Indoor Bike Data monitoring started');
                } catch (e) {
                    log(`‚ÑπÔ∏è FTMS service not available: ${e.message}`);
                }
                
                // Try Cycling Power service
                try {
                    const powerService = await server.getPrimaryService(SERVICES.CYCLING_POWER);
                    const powerMeasurement = await powerService.getCharacteristic('cycling_power_measurement');
                    
                    await powerMeasurement.startNotifications();
                    powerMeasurement.addEventListener('characteristicvaluechanged', handleKickrPowerData);
                    log('‚úÖ Cycling Power monitoring started');
                } catch (e) {
                    log(`‚ÑπÔ∏è Cycling Power service not available: ${e.message}`);
                }
                
                // Try Wahoo custom service
                try {
                    const wahooService = await server.getPrimaryService(SERVICES.WAHOO_TRAINER);
                    const wahooChar = await wahooService.getCharacteristic(SERVICES.WAHOO_TRAINER_CHAR);
                    
                    await wahooChar.startNotifications();
                    wahooChar.addEventListener('characteristicvaluechanged', handleKickrWahooData);
                    log('‚úÖ Wahoo custom service monitoring started');
                } catch (e) {
                    log(`‚ÑπÔ∏è Wahoo custom service not available: ${e.message}`);
                }
                
                // Try Speed/Cadence service
                try {
                    const cscService = await server.getPrimaryService(SERVICES.CYCLING_SPEED_CADENCE);
                    const cscMeasurement = await cscService.getCharacteristic('csc_measurement');
                    
                    await cscMeasurement.startNotifications();
                    cscMeasurement.addEventListener('characteristicvaluechanged', handleKickrSpeedCadence);
                    log('‚úÖ Speed/Cadence monitoring started');
                } catch (e) {
                    log(`‚ÑπÔ∏è Speed/Cadence service not available: ${e.message}`);
                }
                
            } catch (error) {
                log(`‚ùå Failed to start KICKR monitoring: ${error.message}`);
            }
        }

        // Enhanced data handlers for KICKR
        function handleKickrFTMSData(event) {
            try {
                const value = event.target.value;
                const flags = value.getUint16(0, true);
                let offset = 2;
                
                let data = { timestamp: Date.now() };
                
                // Parse FTMS Indoor Bike Data according to spec
                if (flags & 0x01) { // More Data
                    // Speed present
                    if (flags & 0x01) {
                        data.speed = (value.getUint16(offset, true) * 0.01).toFixed(1);
                        offset += 2;
                    }
                }
                
                if (flags & 0x04) { // Average Speed present
                    data.avgSpeed = (value.getUint16(offset, true) * 0.01).toFixed(1);
                    offset += 2;
                }
                
                if (flags & 0x08) { // Instantaneous Cadence present
                    data.cadence = Math.round(value.getUint16(offset, true) * 0.5);
                    offset += 2;
                }
                
                if (flags & 0x40) { // Instantaneous Power present
                    data.power = value.getInt16(offset, true);
                    offset += 2;
                }
                
                if (flags & 0x80) { // Average Power present
                    data.avgPower = value.getInt16(offset, true);
                    offset += 2;
                }
                
                updateKickrMetrics(data);
                log(`üö¥ FTMS Data - Power: ${data.power || 0}W, Cadence: ${data.cadence || 0}RPM, Speed: ${data.speed || 0}km/h`);
                
            } catch (error) {
                log(`‚ùå Error parsing FTMS data: ${error.message}`);
            }
        }

        function handleKickrPowerData(event) {
            try {
                const value = event.target.value;
                const flags = value.getUint16(0, true);
                const power = value.getUint16(2, true);
                
                let data = { power: power, timestamp: Date.now() };
                
                // Check for additional data based on flags
                if (flags & 0x20 && value.byteLength >= 6) { // Crank Revolution Data Present
                    const crankRevs = value.getUint16(4, true);
                    const crankTime = value.getUint16(6, true);
                    // Calculate cadence from crank revolution data
                    data.cadence = Math.round(crankRevs * 1024 / crankTime);
                }
                
                updateKickrMetrics(data);
                log(`‚ö° Power Data - ${power}W${data.cadence ? `, ${data.cadence}RPM` : ''}`);
                
            } catch (error) {
                log(`‚ùå Error parsing power data: ${error.message}`);
            }
        }

        function handleKickrWahooData(event) {
            try {
                const value = event.target.value;
                const dataArray = new Uint8Array(value.buffer);
                
                log(`üîß Wahoo Raw Data: [${Array.from(dataArray).map(b => '0x' + b.toString(16).padStart(2, '0')).join(', ')}]`);
                
                // This would need reverse engineering to decode properly
                // For now, just log the raw data to help with debugging
                
            } catch (error) {
                log(`‚ùå Error parsing Wahoo data: ${error.message}`);
            }
        }

        function handleKickrSpeedCadence(event) {
            try {
                const value = event.target.value;
                const flags = value.getUint8(0);
                let offset = 1;
                
                let data = { timestamp: Date.now() };
                
                if (flags & 0x01) { // Wheel Revolution Data Present
                    const wheelRevs = value.getUint32(offset, true);
                    const wheelTime = value.getUint16(offset + 4, true);
                    data.speed = ((wheelRevs * 2.1 * 3.6) / 1000).toFixed(1); // Assuming 2.1m wheel circumference
                    offset += 6;
                }
                
                if (flags & 0x02) { // Crank Revolution Data Present
                    const crankRevs = value.getUint16(offset, true);
                    const crankTime = value.getUint16(offset + 2, true);
                    data.cadence = Math.round((crankRevs * 1024) / crankTime);
                }
                
                updateKickrMetrics(data);
                log(`üö¥ Speed/Cadence - Speed: ${data.speed || 0}km/h, Cadence: ${data.cadence || 0}RPM`);
                
            } catch (error) {
                log(`‚ùå Error parsing speed/cadence data: ${error.message}`);
            }
        }

        function updateKickrMetrics(data) {
            if (data.power !== undefined) {
                document.getElementById('kickr-power-value').textContent = data.power;
                animateMetricUpdate('kickr-power-metric');
            }
            
            if (data.cadence !== undefined) {
                document.getElementById('kickr-cadence-value').textContent = data.cadence;
                animateMetricUpdate('kickr-cadence-metric');
            }
            
            if (data.speed !== undefined) {
                document.getElementById('kickr-speed-value').textContent = data.speed;
                animateMetricUpdate('kickr-speed-metric');
            }
            
            if (data.resistance !== undefined) {
                document.getElementById('kickr-resistance-value').textContent = data.resistance;
                animateMetricUpdate('kickr-resistance-metric');
            }
            
            document.getElementById('kickr-last-update').textContent = `Last update: ${new Date().toLocaleTimeString()}`;
        }

        // Enhanced Zwift Click pairing
        async function pairZwiftClick() {
            if (!navigator.bluetooth) {
                alert('Web Bluetooth is not supported in this browser');
                return;
            }

            try {
                log('üîç Scanning for Zwift Click...');
                updateDeviceStatus('zwift', 'searching');
                
                const device = await navigator.bluetooth.requestDevice({
                    filters: [
                        { namePrefix: 'Zwift Click' },
                        { namePrefix: 'CLICK' },
                        { services: [SERVICES.HID_SERVICE] },
                        { services: [SERVICES.CYCLING_SPEED_CADENCE] }
                    ],
                    optionalServices: [
                        SERVICES.HID_SERVICE,
                        SERVICES.CYCLING_SPEED_CADENCE,
                        SERVICES.DEVICE_INFORMATION,
                        SERVICES.BATTERY_SERVICE,
                        '12345678-1234-1234-1234-123456789abc' // Generic UUID for discovery
                    ]
                });

                log(`üì± Found device: ${device.name || 'Unknown Click Device'}`);
                
                const server = await device.gatt.connect();
                log('üîó Connected to Zwift Click GATT server');
                
                connectedDevices.set('zwift', {
                    device: device,
                    server: server,
                    type: 'zwift'
                });
                
                updateDeviceStatus('zwift', 'receiving', device.name);
                
                // Discover services for Zwift Click
                await discoverZwiftServices(server);
                
                // Start monitoring
                await monitorZwiftData(server);
                
            } catch (error) {
                log(`‚ùå Zwift Click pairing failed: ${error.message}`);
                updateDeviceStatus('zwift', 'inactive');
                
                if (error.message.includes('User cancelled')) {
                    log('‚ÑπÔ∏è User cancelled device selection');
                } else {
                    log('‚ÑπÔ∏è Try putting your Zwift Click in pairing mode (hold both buttons)');
                }
            }
        }

        async function discoverZwiftServices(server) {
            try {
                log('üîç Discovering Zwift Click services...');
                const services = await server.getPrimaryServices();
                
                let debugInfo = '<strong>Zwift Click Services:</strong><br>';
                debugInfo += `Found ${services.length} services:<br>`;
                
                for (let service of services) {
                    const uuid = service.uuid;
                    debugInfo += `‚Ä¢ ${uuid}`;
                    
                    if (uuid === '00001812-0000-1000-8000-00805f9b34fb') debugInfo += ' (HID Service)';
                    else if (uuid === '0000180f-0000-1000-8000-00805f9b34fb') debugInfo += ' (Battery Service)';
                    else if (uuid === '00001816-0000-1000-8000-00805f9b34fb') debugInfo += ' (Cycling Speed/Cadence)';
                    
                    debugInfo += '<br>';
                    
                    try {
                        const characteristics = await service.getCharacteristics();
                        for (let char of characteristics) {
                            debugInfo += `  ‚îî‚îÄ ${char.uuid}`;
                            if (char.uuid === '00002a4d-0000-1000-8000-00805f9b34fb') debugInfo += ' (HID Report)';
                            else if (char.uuid === '00002a19-0000-1000-8000-00805f9b34fb') debugInfo += ' (Battery Level)';
                            debugInfo += '<br>';
                        }
                    } catch (e) {
                        debugInfo += `  ‚îî‚îÄ Could not read characteristics<br>`;
                    }
                }
                
                updateDebugInfo(debugInfo);
                
            } catch (error) {
                log(`‚ùå Zwift service discovery failed: ${error.message}`);
            }
        }

        async function monitorZwiftData(server) {
            try {
                log('üìä Starting Zwift Click monitoring...');
                
                // Try HID service for button presses
                try {
                    const hidService = await server.getPrimaryService(SERVICES.HID_SERVICE);
                    const reportChar = await hidService.getCharacteristic(SERVICES.HID_REPORT);
                    
                    await reportChar.startNotifications();
                    reportChar.addEventListener('characteristicvaluechanged', handleZwiftButtonPress);
                    log('‚úÖ Zwift Click HID monitoring started');
                } catch (e) {
                    log(`‚ÑπÔ∏è HID service not available: ${e.message}`);
                }
                
                // Try battery service
                try {
                    const batteryService = await server.getPrimaryService(SERVICES.BATTERY_SERVICE);
                    const batteryChar = await batteryService.getCharacteristic('battery_level');
                    
                    const batteryLevel = await batteryChar.readValue();
                    const battery = batteryLevel.getUint8(0);
                    document.getElementById('zwift-battery').textContent = battery;
                    log(`üîã Zwift Click battery: ${battery}%`);
                } catch (e) {
                    log(`‚ÑπÔ∏è Battery service not available: ${e.message}`);
                }
                
                // Try cycling speed/cadence for alternative button detection
                try {
                    const cscService = await server.getPrimaryService(SERVICES.CYCLING_SPEED_CADENCE);
                    const cscChar = await cscService.getCharacteristic('csc_measurement');
                    
                    await cscChar.startNotifications();
                    cscChar.addEventListener('characteristicvaluechanged', handleZwiftAlternativeData);
                    log('‚úÖ Zwift Click alternative monitoring started');
                } catch (e) {
                    log(`‚ÑπÔ∏è Alternative monitoring not available: ${e.message}`);
                }
                
            } catch (error) {
                log(`‚ùå Failed to start Zwift monitoring: ${error.message}`);
            }
        }

        function handleZwiftButtonPress(event) {
            try {
                const value = event.target.value;
                const dataArray = new Uint8Array(value.buffer);
                
                log(`‚ö° Zwift Button Data: [${Array.from(dataArray).map(b => '0x' + b.toString(16).padStart(2, '0')).join(', ')}]`);
                
                // Increment button press counter
                zwiftButtonPresses++;
                document.getElementById('zwift-button-presses').textContent = zwiftButtonPresses;
                
                // Try to detect shift direction (this is device-specific and may need adjustment)
                if (dataArray.length > 0) {
                    const buttonByte = dataArray[0];
                    if (buttonByte & 0x01) { // Example: bit 0 = up shift
                        zwiftShiftUp();
                    } else if (buttonByte & 0x02) { // Example: bit 1 = down shift
                        zwiftShiftDown();
                    }
                }
                
                document.getElementById('zwift-last-update').textContent = `Last update: ${new Date().toLocaleTimeString()}`;
                
            } catch (error) {
                log(`‚ùå Error parsing Zwift button data: ${error.message}`);
            }
        }

        function handleZwiftAlternativeData(event) {
            try {
                const value = event.target.value;
                const dataArray = new Uint8Array(value.buffer);
                
                log(`‚ö° Zwift Alt Data: [${Array.from(dataArray).map(b => '0x' + b.toString(16).padStart(2, '0')).join(', ')}]`);
                
                // This might be used for detecting gear changes through other means
                
            } catch (error) {
                log(`‚ùå Error parsing Zwift alternative data: ${error.message}`);
            }
        }

        function zwiftShiftUp() {
            if (zwiftGear < 12) {
                zwiftGear++;
                document.getElementById('zwift-gear').textContent = zwiftGear;
                log(`‚ö° Shifted UP to gear ${zwiftGear}`);
            }
        }

        function zwiftShiftDown() {
            if (zwiftGear > 1) {
                zwiftGear--;
                document.getElementById('zwift-gear').textContent = zwiftGear;
                log(`‚ö° Shifted DOWN to gear ${zwiftGear}`);
            }
        }

        // Heart Rate Monitor (working version for comparison)
        async function pairHRM() {
            if (!navigator.bluetooth) {
                alert('Web Bluetooth is not supported in this browser');
                return;
            }

            try {
                log('üîç Scanning for Heart Rate Monitor...');
                updateDeviceStatus('hrm', 'searching');
                
                const device = await navigator.bluetooth.requestDevice({
                    filters: [
                        { services: [SERVICES.HEART_RATE] }
                    ],
                    optionalServices: [SERVICES.DEVICE_INFORMATION, SERVICES.BATTERY_SERVICE]
                });

                log(`üì± Found HRM: ${device.name || 'Unknown HRM'}`);
                
                const server = await device.gatt.connect();
                connectedDevices.set('hrm', { device, server, type: 'hrm' });
                
                updateDeviceStatus('hrm', 'receiving', device.name);
                
                const hrService = await server.getPrimaryService(SERVICES.HEART_RATE);
                const hrCharacteristic = await hrService.getCharacteristic('heart_rate_measurement');
                
                await hrCharacteristic.startNotifications();
                hrCharacteristic.addEventListener('characteristicvaluechanged', handleHRMData);
                
                log('‚úÖ Heart Rate monitoring started');
                
            } catch (error) {
                log(`‚ùå HRM pairing failed: ${error.message}`);
                updateDeviceStatus('hrm', 'inactive');
            }
        }

        function handleHRMData(event) {
            try {
                const value = event.target.value;
                const heartRate = value.getUint8(1);
                
                document.getElementById('hr-current-value').textContent = heartRate;
                animateMetricUpdate('hr-current-metric');
                
                // Simple average calculation
                const currentAvg = parseInt(document.getElementById('hr-avg-value').textContent) || heartRate;
                const newAvg = Math.round((currentAvg + heartRate) / 2);
                document.getElementById('hr-avg-value').textContent = newAvg;
                
                document.getElementById('hrm-last-update').textContent = `Last update: ${new Date().toLocaleTimeString()}`;
                
                log(`‚ù§Ô∏è Heart Rate: ${heartRate} BPM`);
                
            } catch (error) {
                log(`‚ùå Error parsing HRM data: ${error.message}`);
            }
        }

        // Disconnect functions
        function disconnectKickr() {
            const connection = connectedDevices.get('kickr');
            if (connection && connection.device.gatt.connected) {
                connection.device.gatt.disconnect();
                connectedDevices.delete('kickr');
                updateDeviceStatus('kickr', 'inactive');
                log('üö¥ KICKR Core disconnected');
            }
        }

        function disconnectZwift() {
            const connection = connectedDevices.get('zwift');
            if (connection && connection.device.gatt.connected) {
                connection.device.gatt.disconnect();
                connectedDevices.delete('zwift');
                updateDeviceStatus('zwift', 'inactive');
                log('‚ö° Zwift Click disconnected');
            }
        }

        function disconnectHRM() {
            const connection = connectedDevices.get('hrm');
            if (connection && connection.device.gatt.connected) {
                connection.device.gatt.disconnect();
                connectedDevices.delete('hrm');
                updateDeviceStatus('hrm', 'inactive');
                log('‚ù§Ô∏è Heart Rate Monitor disconnected');
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            log('üöÄ Fixed ANT+ receiver initialized');
            
            // Check for Web Bluetooth support
            if (!navigator.bluetooth) {
                log('‚ùå Web Bluetooth not supported in this browser');
                log('‚ÑπÔ∏è Try using Chrome, Edge, or another Chromium-based browser');
            } else {
                log('‚úÖ Web Bluetooth is supported');
            }
            
            // Initialize device status
            updateDeviceStatus('kickr', 'inactive');
            updateDeviceStatus('zwift', 'inactive');
            updateDeviceStatus('hrm', 'inactive');
            
            // Handle device disconnections
            document.addEventListener('bluetoothdevicedisconnected', (event) => {
                const deviceName = event.target.name || 'Unknown device';
                log(`‚ö†Ô∏è Device disconnected: ${deviceName}`);
                
                // Find and clean up the disconnected device
                for (let [key, connection] of connectedDevices) {
                    if (connection.device === event.target) {
                        connectedDevices.delete(key);
                        updateDeviceStatus(key, 'inactive');
                        break;
                    }
                }
            });
        });
    </script>
</body>
</html>
